name: üöÄ Build & Deploy All Clients

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  pages:
    runs-on: ubuntu-latest
    steps:
      # 1) Checkout code
      - uses: actions/checkout@v4

      # 2) Setup Node.js (React Router 7 prefers >=20)
      - uses: actions/setup-node@v4
        with:
          node-version: 20

      # 3) Pre-normalize for GH Pages subfolders
      #    - Fix index.html paths
      #    - Ensure vite.config.* has base: '/<slug>/'
      #    - Inject bootstrap with a __DEFAULT_HASH__ placeholder (filled later)
      - name: Pre-normalize projects
        shell: bash
        run: |
          set -e
          for dir in project/*/; do
            slug=$(basename "$dir")
            [ "$slug" = "landingpage" ] && continue
            echo "üßπ Normalizing: $slug"

            # A) Make index.html use relative paths + inject hash bootstrap (with placeholder)
            if [ -f "$dir/index.html" ]; then
              sed -i 's|href="/vite.svg"|href="./vite.svg"|g' "$dir/index.html" || true
              sed -i 's|src="/src/main|src="./src/main|g' "$dir/index.html" || true
              if ! grep -q "__hashbootstrap__" "$dir/index.html"; then
                # Add bootstrap that redirects to /#/__DEFAULT_HASH__ (or /#/) if there is no hash
                perl -0777 -i -pe 's|<body>|<body><script id="__hashbootstrap__">(function(){try{var d="__DEFAULT_HASH__";if(!location.hash){var suf=d?("#/"+d):"#/";location.replace(location.pathname+location.search+suf);}}catch(e){}})();</script>|i' "$dir/index.html"
              fi
            fi

            # B) Ensure vite config has base '/<slug>/'
            cfg="$dir/vite.config.ts"
            [ -f "$dir/vite.config.js" ] && cfg="$dir/vite.config.js"
            if [ ! -f "$cfg" ] || ! grep -q "base: '/$slug/'" "$cfg"; then
              echo "‚úçÔ∏è  Writing vite.config.ts with base '/$slug/'"
              printf "%s\n" \
                "import { defineConfig } from 'vite';" \
                "import react from '@vitejs/plugin-react';" \
                "" \
                "export default defineConfig({" \
                "  plugins: [react()], " \
                "  base: '/$slug/'," \
                "  optimizeDeps: { exclude: ['lucide-react'] }," \
                "});" > "$dir/vite.config.ts"
            fi
          done

      # 4) Normalize routing (only if project already uses react-router-dom)
      - name: Normalize routing to HashRouter (safe)
        shell: bash
        run: |
          set -e
          cat > normalize-router.mjs <<'JS'
          import { promises as fs } from 'fs';
          import path from 'path';

          const ROOT = process.cwd();
          const PROJECTS = path.join(ROOT, 'project');

          const exists = async p => !!(await fs.stat(p).catch(() => null));
          const read = p => fs.readFile(p, 'utf-8');
          const write = (p, s) => fs.writeFile(p, s, 'utf-8');

          const findFirst = async (dir, names) => {
            for (const n of names) {
              const p = path.join(dir, n);
              if (await exists(p)) return p;
            }
            return null;
          };

          const ensureHashImport = (src) => {
            return src.replace(
              /import\s*\{([^}]*)\}\s*from\s*['"]react-router-dom['"];/,
              (_, list) => {
                const names = list.split(',').map(s => s.trim()).filter(Boolean);
                if (!names.includes('HashRouter')) names.push('HashRouter');
                return `import { ${names.join(', ')} } from 'react-router-dom';`;
              }
            );
          };

          const addHashImportIfMissing = (src) => {
            if (!/from ['"]react-router-dom['"]/.test(src)) return src;
            if (!/HashRouter/.test(src)) return ensureHashImport(src);
            return src;
          };

          const wrapAppWithHashRouter = (src) => {
            if (/<HashRouter>[\s\S]*<\/HashRouter>/.test(src)) return src;
            if (!/from ['"]react-router-dom['"]/.test(src)) return src;
            return src
              .replace(/<App\s*\/>/, '<HashRouter><App /></HashRouter>')
              .replace(/<App\/>/, '<HashRouter><App /></HashRouter>');
          };

          const stripBrowserRouter = (src) => {
            if (!/from ['"]react-router-dom['"]/.test(src)) return src;
            let out = src.replace(/<BrowserRouter[^>]*>/g, '')
                         .replace(/<\/BrowserRouter>/g, '');
            out = out.replace(
              /import\s*\{([^}]*)\}\s*from\s*['"]react-router-dom['"];/g,
              (_, list) => {
                const names = list.split(',').map(s => s.trim()).filter(n => n && n !== 'BrowserRouter');
                return names.length
                  ? `import { ${names.join(', ')} } from 'react-router-dom';`
                  : '';
              }
            );
            return out;
          };

          const run = async () => {
            const items = await fs.readdir(PROJECTS).catch(() => []);
            for (const slug of items) {
              if (slug === 'landingpage') continue;
              const dir = path.join(PROJECTS, slug);
              const stat = await fs.stat(dir).catch(() => null);
              if (!stat || !stat.isDirectory()) continue;

              const mainPath = await findFirst(dir, ['src/main.tsx','src/main.jsx','src/main.ts','src/main.js']);
              const appPath  = await findFirst(dir, ['src/App.tsx','src/App.jsx','src/App.ts','src/App.js']);

              let usesRouter = false;
              if (mainPath && /react-router-dom/.test(await read(mainPath))) usesRouter = true;
              if (!usesRouter && appPath && /react-router-dom/.test(await read(appPath))) usesRouter = true;
              if (!usesRouter) continue;

              if (mainPath) {
                let src = await read(mainPath);
                const before = src;
                src = addHashImportIfMissing(src);
                src = wrapAppWithHashRouter(src);
                if (src !== before) {
                  await write(mainPath, src);
                  console.log(`‚úî updated ${path.relative(ROOT, mainPath)}`);
                }
              }

              if (appPath) {
                let src = await read(appPath);
                const out = stripBrowserRouter(src);
                if (out !== src) {
                  await write(appPath, out);
                  console.log(`‚úî updated ${path.relative(ROOT, appPath)}`);
                }
              }
            }
          };

          run().catch(err => { console.error(err); process.exit(0); });
          JS

          node normalize-router.mjs

      # 5) Detect first route and set default hash target for each project
      - name: Detect routes and set default hash
        shell: bash
        run: |
          set -e
          cat > detect-routes.mjs <<'JS'
          import { promises as fs } from 'fs';
          import path from 'path';

          const ROOT = process.cwd();
          const PROJECTS = path.join(ROOT, 'project');

          const exists = async p => !!(await fs.stat(p).catch(() => null));
          const read = p => fs.readFile(p, 'utf-8');

          const routeRegexes = [
            /<Route[^>]*\spath=["']([^"']+)["'][^>]*>/g,                        // <Route path="x" ...>
            /path\s*:\s*["']([^"']+)["']/g,                                     // path: 'x'
            /createBrowserRouter\(\s*\[\s*\{\s*path:\s*["']([^"']+)["']/g,      // createBrowserRouter([{ path: 'x'
            /createHashRouter\(\s*\[\s*\{\s*path:\s*["']([^"']+)["']/g          // createHashRouter([{ path: 'x'
          ];

          const bad = new Set(['', '/', '*']);
          const pickFirstRoute = (code) => {
            for (const rx of routeRegexes) {
              rx.lastIndex = 0;
              const m = rx.exec(code);
              if (m && m[1] && !bad.has(m[1])) return m[1].replace(/^\//,''); // drop leading slash
            }
            return ''; // no specific route ‚Üí use '/'
          };

          const run = async () => {
            const slugs = await fs.readdir(PROJECTS).catch(() => []);
            for (const slug of slugs) {
              if (slug === 'landingpage') continue;
              const dir = path.join(PROJECTS, slug);
              const stat = await fs.stat(dir).catch(() => null);
              if (!stat || !stat.isDirectory()) continue;

              // read all src files we care about
              const candidates = [
                'src/App.tsx','src/App.jsx','src/App.ts','src/App.js',
                'src/main.tsx','src/main.jsx','src/main.ts','src/main.js',
                'src/routes.tsx','src/routes.jsx','src/routes.ts','src/routes.js'
              ].map(f => path.join(dir, f));

              let combined = '';
              for (const p of candidates) {
                if (await exists(p)) combined += await read(p) + '\n';
              }

              const def = pickFirstRoute(combined);
              const idx = path.join(dir, 'index.html');
              if (await exists(idx)) {
                let html = await read(idx);
                html = html.replace(/__DEFAULT_HASH__/g, def);
                await fs.writeFile(idx, html, 'utf-8');
                console.log(`‚úî ${slug} default route: ${def || '(root)'}`);
              }
            }
          };

          run().catch(err => { console.error(err); process.exit(0); });
          JS

          node detect-routes.mjs

      # 6) Build each client demo (skip landingpage)
      - name: Build demos
        shell: bash
        run: |
          set -e
          for dir in project/*/; do
            slug=$(basename "$dir")
            [ "$slug" = "landingpage" ] && continue

            echo "üî® Considering demo: $slug"
            if [ ! -f "$dir/package.json" ]; then
              echo "‚û°Ô∏è  Skipping $slug (no package.json)"
              continue
            fi

            echo "üîß Installing deps for: $slug"
            cd "$dir"
            if [ -f package-lock.json ]; then
              npm ci
            else
              npm install --no-audit --no-fund
            fi

            echo "üèó  Building: $slug"
            if npm run -s build; then
              echo "‚úÖ Built with npm run build"
            else
              echo "‚ÑπÔ∏è  Falling back to npx vite build for $slug"
              npx vite build
            fi

            cd ../../

            if [ -d "project/$slug/dist" ]; then
              rm -rf "$slug"
              mkdir -p "$slug"
              cp -r "project/$slug/dist/." "$slug/"
            else
              echo "‚ö†Ô∏è  $slug built but no dist/ found ‚Äî skipping copy"
            fi
          done

      # 7) Build & copy landing page into root
      - name: Build landing page
        shell: bash
        run: |
          cd project/landingpage
          npm ci
          npm run build
          cd ../../
          cp -r project/landingpage/dist/* .

      # 8) Dynamic SPA fallback for ALL paths
      - name: Create smart 404.html
        shell: bash
        run: |
          echo '<!DOCTYPE html><html><head><meta charset="utf-8"><title>Redirecting</title></head><body><script>var p=location.pathname.split("/").filter(Boolean);if(p.length>0){var s=p[0];var r=p.slice(1).join("/");var h=r?"#/"+r:"";window.location.replace("/"+s+"/index.html"+h);}else{window.location.replace("/index.html");}</script><p>Redirecting...</p></body></html>' > 404.html

      # 9) Debug: list everything that will be published
      - name: Show publish directory
        shell: bash
        run: |
          echo "=== publish contents ==="
          ls -R .
          echo "========================"

      # 10) Deploy to GitHub Pages
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: gh-pages
          publish_dir: ./
